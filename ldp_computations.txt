import akdot_nr_ldp_v1 as ldp
import LambertConformalConic as LCC
import numpy as np

# This is just a scatch pad to run akdot_r_ldp_v1 for computations.

# global constant for converting meters to us survey feet
usft = 3937.0 / 1200.0  # 1 meter = 3937/1200 US Survey feet
a = 6378137 #semi-major axis (a) GRS-80, meters
inFl = 298.257222100882 #inverse flattening (1/f) unitless


# control point to check, ortho is meters 
#phi    = ldp.min2Dec(64,39,46.57719)
#lam    = ldp.min2Dec(-148,59,2.08202)
#h      = 382.0751 * usft ** -1 # ellipsoid height or ortho height. Which ever you want to want to check at.
#phiO    = ldp.min2Dec(63,2,00.0)
#kO = 1.000046
#lam    = -148.4362289
#h      = 6.47  # ellipsoid height or ortho height. Which ever you want to want to check at.
# point = Ajo
#phi    = ldp.min2Dec(64,17,25.094490)     # Alaksa LDP Origin
#lam    = ldp.min2Dec(-146,22,51.154570)
#h      = 318.0770

#phi    = ldp.min2Dec(63,36,19.46405)  # THOMPSON
#lam    = ldp.min2Dec(-143,58,11.00259)
#h      = 484.415
#phi    = ldp.min2Dec(63,20,00.10829)   # STRIP, from ROS for TOK AP
#lam    = ldp.min2Dec(-142,57,11.17509)
#h      = 1552 * 1200/3937


phi    = ldp.min2Dec(64,50,56.36374) # 430M
lam    = ldp.min2Dec(-147,47,46.72655)
h      = 142.72067

#phi    = ldp.min2Dec(64,50,56.30560) # 1000M
#lam    = ldp.min2Dec(-147,47,03.47618)
#h      = 143.97419

Rg     = ldp.geMeRaCu(phi) # geometric mean radius of curvature, in meters
EF     = Rg/(Rg + h) # Elevation Factor

#test_PhiO = ldp.min2Dec(32,15,00)
#test_LamO = ldp.min2Dec(-111,24,00)
#test_kO   = 1.000110
#test_Skew = 45

# paramters for using LCC, requires projection definition
phiO = np.deg2rad(ldp.min2Dec(64,51,0.0)) # standard parallel
phi1 = np.deg2rad(ldp.min2Dec(64,51,0.0)) # standard parallel
phi2 = np.deg2rad(ldp.min2Dec(0,0,0.0)) # standard parallel
lamO = np.deg2rad(ldp.min2Dec(-146,56,0.0))
FN = 200000.0 * usft ** -1   # convert this value, which is in usft, to meters.
FE = 800000.0 * usft ** -1   # convert this value, which is in usft, to meters.
kO = 1.00003

test1   = ldp.Fairbanks(phi,lam) 
test2   = ldp.AKSPZ3(phi,lam) 
test3   = LCC.generic_LCC(phi, phiO, phi1, phi2, lam, lamO, FN, FE, kO, a, inFl)

#genTM1   = ldp.genericTM(phi,lam,test_LamO, test_kO)
#gen1      = ldp.genericOM(phi, test_PhiO, lam, test_LamO, test_Skew, test_kO)
#RichZ1 = ldp.Richardson_Hwy_Zone_1(phi,lam)
#RichZ2 = ldp.Richardson_Hwy_Zone_2(phi,lam)
#RichZ3 = ldp.Richardson_Hwy_Zone_3(phi,lam)
#Valdez = ldp.Valdez(phi,lam)
#UTMZ6   = ldp.UTM6N(phi,lam)
#UTMZ4   = ldp.UTM4N(phi,lam)
#projection = ldp.Cordova(phi,lam)
#projection = ldp.AKSPZ2(phi,lam)

##projection = ldp.generic_LCC(phi,phiO,kO)


#print ("PCCS_1E", "E:", "%.3f" % (test1[0] * usft), "N:", "%.3f" % (test1[1] * usft), "k:", test1[2], "EF:", EF, "CSF:", "%.12f" % (test1[2] * EF), "   d(ppm) =", "%.2f" % ((test1[2] * EF -1) * 1000000))
#print ("ddd", "E:", "%.3f" % (test2[0] * usft), "N:", "%.3f" % (test2[1] * usft), "k:", test2[2], "EF:", EF, "CSF:", "%.12f" % (test2[2] * EF), "   d(ppm) =", "%.2f" % ((test2[2] * EF -1) * 1000000))
#print ("generic",  "k:", gen1, "EF:", EF, "CSF:", "%.12f" % (gen1 * EF), "   d(ppm) =", "%.2f" % ((gen1 * EF -1) * 1000000))
#X = ldp.ecefX(phi,lam,h)
#Y = ldp.ecefY(phi,lam,h)
#Z = ldp.ecefZ(phi,h)

#geo = ldp.geoECEF(X,Y,Z)

# print out the answers (can do so in usft if desired)
#print ("SPZ3  ", "E:", "%.3f" % (AKZ3[0] * usft), "N:", "%.3f" % (AKZ3[1] * usft), "k:", AKZ3[2], "EF:", EF, "CSF:", "%.12f" % (AKZ3[2] * EF), "   d(ppm) =", "%.2f" % ((AKZ3[2] * EF -1) * 1000000))
#print ("Frbnks", "E:", "%.3f" % (FbkLDP[0] * usft), "N:", "%.3f" % (FbkLDP[1] * usft), "k:", FbkLDP[2], "EF:", EF, "CSF:", "%.12f" % (FbkLDP[2] * EF), "   d(ppm) =", "%.2f" % ((FbkLDP[2] * EF -1) * 1000000))
#print ("RichZ1", "E:", "%.3f" % (RichZ1[0] * usft), "N:", "%.3f" % (RichZ1[1] * usft), "k:", RichZ1[2], "EF:", EF, "CSF:", "%.12f" % (RichZ1[2] * EF), "   d(ppm) =", "%.2f" % ((RichZ1[2] * EF -1) * 1000000))
#print ("RichZ2", "E:", "%.3f" % (RichZ2[0] * usft), "N:", "%.3f" % (RichZ2[1] * usft), "k:", RichZ2[2], "EF:", EF, "CSF:", "%.12f" % (RichZ2[2] * EF), "   d(ppm) =", "%.2f" % ((RichZ2[2] * EF -1) * 1000000))
#print ("RichZ3", "E:", "%.3f" % (RichZ3[0] * usft), "N:", "%.3f" % (RichZ3[1] * usft), "k:", RichZ3[2], "EF:", EF, "CSF:", "%.12f" % (RichZ3[2] * EF), "   d(ppm) =", "%.2f" % ((RichZ3[2] * EF -1) * 1000000))
#print ("Valdez", "E:", "%.3f" % (Valdez[0] * usft), "N:", "%.3f" % (Valdez[1] * usft), "k:", Valdez[2], "EF:", EF, "CSF:", "%.12f" % (Valdez[2] * EF), "   d(ppm) =", "%.2f" % ((Valdez[2] * EF -1) * 1000000))
#print ("UTM4N", "E:", "%.3f" % UTMZ4[0], "N:", "%.3f" % UTMZ4[1], "k:", UTMZ4[2], "EF:", EF, "CSF:", "%.12f" % (UTMZ4[2] * EF), "   d(ppm) =", "%.2f" % ((UTMZ4[2] * EF -1) * 1000000))
#print ("UTM6N", "E:", "%.3f" % UTMZ6[0], "N:", "%.3f" % UTMZ6[1], "k:", UTMZ6[2], "EF:", EF, "CSF:", "%.12f" % (UTMZ6[2] * EF), "   d(ppm) =", "%.2f" % ((UTMZ6[2] * EF -1) * 1000000))
#print ("SPZ7 ", "E:", "%.3f" % AKZ7[0],  "N:", "%.3f" % AKZ7[1],  "k:", AKZ7[2],  "EF:", EF, "CSF:", "%.12f" % (AKZ7[2] * EF),  "   d(ppm) =", "%.2f" % ((AKZ7[2] * EF -1) * 1000000))
#print (X, Y, Z)
#print (phi, lam, h)
#print (geo[0], geo[1], geo[2])

#meters
#print ("computed", "N:", "%.3f" % (projection[1]), "E:", "%.3f" % (projection[0]), "k:", projection[2], "EF:", EF, "CSF:", "%.12f" % (projection[2] * EF), "   d(ppm) =", "%.2f" % ((projection[2] * EF -1) * 1000000))

#usft
print ("computed", "N:", "%.3f" % (test1[1] * usft), "E:", "%.3f" % (test1[0] * usft), "k:", test1[2], "EF:", EF, "CSF:", "%.12f" % (test1[2] * EF), "   d(ppm) =", "%.2f" % ((test1[2] * EF -1) * 1000000))
print ("computed", "N:", "%.3f" % (test2[1] * usft), "E:", "%.3f" % (test2[0] * usft), "k:", test2[2], "EF:", EF, "CSF:", "%.12f" % (test2[2] * EF), "   d(ppm) =", "%.2f" % ((test2[2] * EF -1) * 1000000))
print ("computed", "N:", "%.3f" % (test3[1] * usft), "E:", "%.3f" % (test3[0] * usft), "k:", test3[2], "EF:", EF, "CSF:", "%.12f" % (test2[3] * EF), "   d(ppm) =", "%.2f" % ((test3[2] * EF -1) * 1000000))

# meters
#print ("computed", "N:", "%.3f" % (projection[1]), "E:", "%.3f" % (projection[0]), "k:", projection[2], "EF:", EF, "CSF:", "%.12f" % (projection[2] * EF), "   d(ppm) =", "%.2f" % ((projection[2] * EF -1) * 1000000))


#print ("computed", "k:", projection, "EF:", EF, "CSF:", "%.12f" % (projection * EF), "   d(ppm) =", "%.2f" % ((projection * EF -1) * 1000000))
