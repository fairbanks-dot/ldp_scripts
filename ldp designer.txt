import numpy as np
import akdot_nr_ldp_v1 as ldp

# This is file for finding parameters for projectionsto best fit test points.
#
# Troy Hicks
# last revision: mar 12, 2018
#
# notes: added some points to test points. Also started to write kO optimization routine
#


# global constant for converting meters to us survey feet
usft = 3937.0 / 1200.0  # 1 meter = 3937/1200 US Survey feet

# test points, in decimal degrees, Lat, long, then Ellipsoid Height in meters.
points = np.array([
[64.9063761,	-146.5417525,	218.6231671],
[64.8798801,	-146.8861529,	181.9721218],
[64.8845589,	-147.4116119,	165.3694183],
[64.7721692,	-147.3534048,	132.3634226],
[64.8109699,	-147.5869071,	135.6204677],
[64.8420138,	-147.7327000,	132.1732663],
[64.8302706,	-147.8254979,	123.1722072],
[64.8887617,	-147.9239526,	172.5458688],
[64.8002849,	-147.9359196,	129.1778060],
[64.8619305,	-147.7491329,	138.4075775],
[64.7092492,	-147.1659452,	153.4607061],
[64.9435409,	-147.6534785,	210.304191],
[65.0514906,	-146.1888838,	309.3726187],])


#print ("ndim  = ",(points.ndim))
#print ("shape = ",(points.shape))

################################################################################
################################################################################
#
# Lambert Conformal Conic Projection parameter OPTIMIZER
# ------------------------------------------------------
#     Uses brute force to find the best values for PhiO and kO
#     against supplied test points. Best fit to the points.
#     The linear distortion at each point is computed based on various values of
#     either PhiO or kO. For PhiO, the variance of distortion values for
#     the test points is minimized. For kO the average of the distortion values
#     is minimized. 
#
################################################################################
# Optimize the PhiO parameter
#
#      accomplished by finding the PhiO that has the minimum standard deviation
#      of linear distortion per test point
#
#  note: change min, to min_PhiO  test to test_PhiO
#
################################################################################
min_PhiO = (np.amin(points[:,0])) -2
max_PhiO = (np.amax(points[:,0])) +2
step_PhiO = 15 # seconds to step for each test
step_PhiO = step_PhiO / 3600 # convert to decimal
tries_PhiO = np.int((max_PhiO-min_PhiO) / step_PhiO)
results_PhiO = np.zeros([tries_PhiO,2]) 
#results_PhiO = np.zeros([tries_PhiO,points.shape[0] + 2]) 
test_PhiO = min_PhiO  # start the test with the minimum value
#best_stdDev = 10000000000.0  # reset best standard dev to high number, so we can find lowest
for c in range(np.int(tries_PhiO)) :
   # for each overall PhiO try, sample the distortion for the test points
   try_PhiO_sample = np.zeros([1,points.shape[0]]) 
   for i in range(points.shape[0]) :
      Rg = ldp.geMeRaCu(points[i][2])
      EF = Rg/(Rg + points[i][2])
      k = ldp.genericLCC(points[i][0],test_PhiO,1.2)  # needs a (phi, phiO, kO)
      d = (EF * k - 1) * 1000000  # d = linear distortion in units of ppm
      try_PhiO_sample[0][i-1] = d
   results_PhiO[c][points.shape[0]] =  test_PhiO  # whatever test value, save it here. phi, or lam, or kO
   stdDev = np.std(results_PhiO[c][0:points.shape[0]-1])
   results_PhiO[c][points.shape[0] + 1] = stdDev
   if best_stdDev > stdDev :
       best_stdDev = stdDev
       best_PhiO = test_PhiO
   # print (c,test, np.std(results[c][0:10]))
   test_PhiO = test_PhiO + step_PhiO   # increase test value to next
# the best answer for PhiO, within selected range, is:
print ("PhiO:",best_PhiO, "   sigma:",best_stdDev)


################################################################################
# Optimize the kO parameter
#
#      accomplished by finding the kO that has the minimum average
#      of linear distortion per test point
#
#   notes: copied above, change to min_kO, and test to test_kO etc.
#
################################################################################
min_kO = 0.9  
max_kO = 1.1
#step_kO = 0.00001
step_kO = 0.001

tries_kO = np.int((max_kO-min_kO) / step_kO)
results_kO = np.zeros([tries_kO,points.shape[0] + 2]) 
test_kO = min_kO  # start the test with the minimum value
best_kO = min_kO  # reset best average to any number, so we can find lowest
best_avg = 10000000.0 # rest average to high number, so we can find a low one
for c in range(np.int(tries_kO)) :
   for i in range(points.shape[0]) :
      Rg = ldp.geMeRaCu(points[i][2])
      EF = Rg/(Rg + points[i][2])
      k = ldp.genericLCC(points[i][0],best_PhiO,test_kO)  # needs a (phi, phiO, kO)
      d = (EF * k - 1) * 1000000
      results_kO[c][i] = d
   results_kO[c][points.shape[0]] =  test_kO  # whatever test value, save it here. phi, or lam, or kO
   avg = np.average(results_kO[c][0:points.shape[0]-1])
   results_kO[c][points.shape[0] + 1] = avg
   if best_kO > avg :
       best_kO = test_kO
       best_avg = avg
   # print (c,test, np.std(results[c][0:10]))
   test_kO = test_kO + step_kO   # increase test value to next
# the best answer for PhiO, within selected range, is:
print ("kO:",best_kO, "  average:", best_avg)


















#print (np.std(results))
#print (np.average(results))
#print (results)




